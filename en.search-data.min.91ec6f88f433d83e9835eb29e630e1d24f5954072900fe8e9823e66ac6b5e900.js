'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-network/docs/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':1,'href':'/study-network/docs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':2,'href':'/study-network/docs/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':3,'href':'/study-network/docs/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':4,'href':'/study-network/docs/design/','title':"第二部分 设计",'content':""});index.add({'id':5,'href':'/study-network/docs/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':6,'href':'/study-network/docs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':7,'href':'/study-network/docs/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':8,'href':'/study-network/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':9,'href':'/study-network/docs/basic/protocol/dns/','title':"DNS",'content':"DNS /etc/hosts hosts 文件是 Linux 系统中一个负责 IP 地址与域名快速解析的文件\n/etc/resolv.conf 该文件是 DNS 域名解析的配置文件，它的格式很简单， 每行以一个关键字开头，后接配置参数。\nresolv.conf 的关键字主要有四个：\n nameserver # 定义 DNS 服务器的 IP 地址 domain # 定义本地域名 search # 定义域名的搜索列表 sortlist # 对返回的域名进行排序  最主要是 nameserver 关键字，如果没指定 nameserver 就找不到 DNS 服务器，其它关键字是可选的。\ndomain centoscn.com search www.centocn.com www.wgjlb.com nameserver 202.96.128.86 nameserver 202.96.128.166 /etc/host.conf 解析器查询顺序配置文件\n# 表示先查询本地 hosts 文件，如果没有结果，再尝试查找 BIND dns 服务器 order hosts bind "});index.add({'id':10,'href':'/study-network/docs/basic/practice/epoll/','title':"epoll",'content':"epoll 阻塞  多进程 多线程  非阻塞 忙轮询 while true { for i in 流[] { if i has 数据 { 读 或者 其他处理 } } } select select 代收员 比较懒，她只会告诉你快递到了，但是是谁到的，你需要挨个快递员问一遍。\nwhile true { select(流[]); # 阻塞 for i in 流[] { if i has 数据 { 读 或者 其他处理 } } } epoll while true { 可处理的流[] = epoll_wait(epoll_fd); # 阻塞 for i in 可处理的流[] { 读 或者 其他处理 } } epoll 编程框架 //创建 epoll int epfd = epoll_crete(1000); //将 listen_fd 添加进 epoll 中 epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, \u0026amp;listen_event); while (1) { //阻塞等待 epoll 中 的 fd 触发  int active_cnt = epoll_wait(epfd, events, 1000, -1); for (i = 0 ; i \u0026lt; active_cnt; i++) { if (evnets[i].data.fd == listen_fd) { //accept. 并且将新 accept 的 fd 加进 epoll 中.  } else if (events[i].events \u0026amp; EPOLLIN) { //对此 fd 进行读操作  } else if (events[i].events \u0026amp; EPOLLOUT) { //对此 fd 进行写操作  } } } 服务端 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;ctype.h\u0026gt;#include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #define SERVER_PORT (7778) #define EPOLL_MAX_NUM (2048) #define BUFFER_MAX_LEN (4096)  char buffer[BUFFER_MAX_LEN]; void str_toupper(char *str) { int i; for (i = 0; i \u0026lt; strlen(str); i ++) { str[i] = toupper(str[i]); } } int main(int argc, char **argv) { int listen_fd = 0; int client_fd = 0; struct sockaddr_in server_addr; struct sockaddr_in client_addr; socklen_t client_len; int epfd = 0; struct epoll_event event, *my_events; // socket  listen_fd = socket(AF_INET, SOCK_STREAM, 0); // bind  server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(SERVER_PORT); bind(listen_fd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr)); // listen  listen(listen_fd, 10); // epoll create  epfd = epoll_create(EPOLL_MAX_NUM); if (epfd \u0026lt; 0) { perror(\u0026#34;epoll create\u0026#34;); goto END; } // listen_fd -\u0026gt; epoll  event.events = EPOLLIN; event.data.fd = listen_fd; if (epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, \u0026amp;event) \u0026lt; 0) { perror(\u0026#34;epoll ctl add listen_fd \u0026#34;); goto END; } my_events = malloc(sizeof(struct epoll_event) * EPOLL_MAX_NUM); while (1) { // epoll wait  int active_fds_cnt = epoll_wait(epfd, my_events, EPOLL_MAX_NUM, -1); int i = 0; for (i = 0; i \u0026lt; active_fds_cnt; i++) { // if fd == listen_fd  if (my_events[i].data.fd == listen_fd) { //accept  client_fd = accept(listen_fd, (struct sockaddr*)\u0026amp;client_addr, \u0026amp;client_len); if (client_fd \u0026lt; 0) { perror(\u0026#34;accept\u0026#34;); continue; } char ip[20]; printf(\u0026#34;new connection[%s:%d]\\n\u0026#34;, inet_ntop(AF_INET, \u0026amp;client_addr.sin_addr, ip, sizeof(ip)), ntohs(client_addr.sin_port)); event.events = EPOLLIN | EPOLLET; event.data.fd = client_fd; epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, \u0026amp;event); } else if (my_events[i].events \u0026amp; EPOLLIN) { printf(\u0026#34;EPOLLIN\\n\u0026#34;); client_fd = my_events[i].data.fd; // do read  buffer[0] = \u0026#39;\\0\u0026#39;; int n = read(client_fd, buffer, 5); if (n \u0026lt; 0) { perror(\u0026#34;read\u0026#34;); continue; } else if (n == 0) { epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, \u0026amp;event); close(client_fd); } else { printf(\u0026#34;[read]: %s\\n\u0026#34;, buffer); buffer[n] = \u0026#39;\\0\u0026#39;; #if 1  str_toupper(buffer); write(client_fd, buffer, strlen(buffer)); printf(\u0026#34;[write]: %s\\n\u0026#34;, buffer); memset(buffer, 0, BUFFER_MAX_LEN); #endif  /* event.events = EPOLLOUT; event.data.fd = client_fd; epoll_ctl(epfd, EPOLL_CTL_MOD, client_fd, \u0026amp;event); */ } } else if (my_events[i].events \u0026amp; EPOLLOUT) { printf(\u0026#34;EPOLLOUT\\n\u0026#34;); /* client_fd = my_events[i].data.fd; str_toupper(buffer); write(client_fd, buffer, strlen(buffer)); printf(\u0026#34;[write]: %s\\n\u0026#34;, buffer); memset(buffer, 0, BUFFER_MAX_LEN); event.events = EPOLLIN; event.data.fd = client_fd; epoll_ctl(epfd, EPOLL_CTL_MOD, client_fd, \u0026amp;event); */ } } } END: close(epfd); close(listen_fd); return 0; } 客户端 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;strings.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt; #define MAX_LINE (1024) #define SERVER_PORT (7778)  void setnoblocking(int fd) { int opts = 0; opts = fcntl(fd, F_GETFL); opts = opts | O_NONBLOCK; fcntl(fd, F_SETFL); } int main(int argc, char **argv) { int sockfd; char recvline[MAX_LINE + 1] = {0}; struct sockaddr_in server_addr; if (argc != 2) { fprintf(stderr, \u0026#34;usage ./client \u0026lt;SERVER_IP\u0026gt;\\n\u0026#34;); exit(0); } // 创建socket  if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { fprintf(stderr, \u0026#34;socket error\u0026#34;); exit(0); } // server addr 赋值  bzero(\u0026amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(SERVER_PORT); if (inet_pton(AF_INET, argv[1], \u0026amp;server_addr.sin_addr) \u0026lt;= 0) { fprintf(stderr, \u0026#34;inet_pton error for %s\u0026#34;, argv[1]); exit(0); } // 链接服务端  if (connect(sockfd, (struct sockaddr*) \u0026amp;server_addr, sizeof(server_addr)) \u0026lt; 0) { perror(\u0026#34;connect\u0026#34;); fprintf(stderr, \u0026#34;connect error\\n\u0026#34;); exit(0); } setnoblocking(sockfd); char input[100]; int n = 0; int count = 0; // 不断的从标准输入字符串  while (fgets(input, 100, stdin) != NULL) { printf(\u0026#34;[send] %s\\n\u0026#34;, input); n = 0; // 把输入的字符串发送 到 服务器中去  n = send(sockfd, input, strlen(input), 0); if (n \u0026lt; 0) { perror(\u0026#34;send\u0026#34;); } n = 0; count = 0; // 读取 服务器返回的数据  while (1) { n = read(sockfd, recvline + count, MAX_LINE); if (n == MAX_LINE) { count += n; continue; } else if (n \u0026lt; 0){ perror(\u0026#34;recv\u0026#34;); break; } else { count += n; recvline[count] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;[recv] %s\\n\u0026#34;, recvline); break; } } } return 0; } 参考  Libevent 深入浅出  "});index.add({'id':11,'href':'/study-network/docs/basic/protocol/http/','title':"HTTP",'content':"HTTP "});index.add({'id':12,'href':'/study-network/docs/basic/cmd/iptables/','title':"iptables",'content':"iptables Linux 的包过滤功能，即 Linux 防火墙， 它由 netfilter 和 iptables 两个组件组成。 netfilter 组件也称为内核空间，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。 iptables 组件是一种工具，位于用户空间，它使插入、修改和除去信息包过滤表中的规则变得容易。\n原理  一个数据包进入网卡时，它首先进入 PREROUTING 链，内核根据数据包目的 IP 判断是否需要转发出去 如果数据包就是进入本机的，它就会沿着图向下移动，到达 INPUT 链 数据包到了 INPUT 链后，任何进程都会收到它。 如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD 链， 然后到达 POSTROUTING 链输出。 本机上运行的程序可以发送数据包，这些数据包会经 过 OUTPUT 链 然后到达 POSTROUTING 链输出   状态 ESTABLISHED 状态 ESTABLISHED 指出该信息包属于已建立的连接，该连接一直用于发送和接收信息包并且完全有效。\nINVALID INVALID 状态指出该信息包与任何已知的流或连接都不相关联，它可能包含错误的数据或头。\nNEW 状态 NEW 意味着该信息包已经或将启动新的连接，或者它与尚未用于发送和接收信息包的连接相关联。\nRELATED RELATED 表示该信息包正在启动新连接，以及它与已建立的连接相关联。\n 规则 /rules  规则（rules）其实就是网络管理员预定义的条件， 规则一般的定义为 \u0026ldquo;如果数据包头符合这样的条件，就这样处理这个数据包\u0026rdquo;。 规则存储在内核空间的信息包过滤表中， 这些规则分别指定了**源地址、目的地址、传输协议（如 TCP、UDP、ICMP）和服务类型（如 HTTP、FTP 和 SMTP）**等。 当数据包与规则匹配时，iptables 就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。 配置防火墙的主要工作就是添加、修改和删除这些规则。   基础命令 iptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转]\n 表 /tables Raw   RAW 表 只使用在 PREROUTING 链和 OUTPUT 链上，因为优先级最高，\n  从而可以对收到的数据包在连接跟踪前进行处理。\n  一但用户使用了 RAW 表，在 某个链上，RAW 表处理完后，将跳过 NAT 表和 ip_conntrack 处理，\n  即不再做地址转换和数据包的链接跟踪处理了.\n  Mangle  主要用于对指定数据包进行更改， 在内核版本 2.4.18 后的 linux 版本中该表包含的链为：INPUT 链（处理进入的数据包），RORWARD 链（处理转发的数据包），OUTPUT 链（处理本地生成的数据包）POSTROUTING 链（修改即将出去的数据包），PREROUTING 链（修改即将到来的数据包）  NAT  主要用于网络地址转换 NAT，该表可以实现一对一，一对多，多对多等 NAT 工作， iptables 就是使用该表实现共享上网的， NAT 表包含了 PREROUTING 链（修改即将到来的数据包），POSTROUTING 链（修改即将出去的数据包），OUTPUT 链（修改路由之前本地生成的数据包）  Filter   Filter 表是默认的表，\n  如果没有指定哪个表，iptables 就默认使用 filter 表来执行所有命令，\n  filter 表包含了 INPUT 链（处理进入的数据包），RORWARD 链（处理转发的数据包），OUTPUT 链（处理本地生成的数据包）\n  在 filter 表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改\n  security 用于强制访问控制网络规则\n表具有的链类型    规则名称 raw mangle nat filter security     PREROUTING ✓ ✓ ✓     INPUT  ✓ ✓ ✓ ✓   OUTPUT  ✓ ✓ ✓ ✓   POSTROUTING  ✓ ✓     FORWARD ✓ ✓  ✓ ✓     命令选项 命令选项用于指定 iptables 的执行方式，包括插入规则，删除规则和添加规则，如下表所示\n   短命令 长命令 说明     -P \u0026ndash;policy 定义默认策略   -L \u0026ndash;list 查看 iptables 规则列表   -A \u0026ndash;append 在规则列表的最后增加 1 条规则   -I \u0026ndash;insert 在指定的位置插入 1 条规则   -D \u0026ndash;delete 从规则列表中删除 1 条规则   -R \u0026ndash;replace 替换规则列表中的某条规则   -F \u0026ndash;flush 删除表中所有规则   -Z \u0026ndash;zero 将表中数据包计数器和流量计数器归零   -X \u0026ndash;delete-chain 删除自定义链   -v \u0026ndash;verbose 与 - L 他命令一起使用显示更多更详细的信息     链 /chains  当一个数据包到达一个链时，iptables 就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。 如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则 iptables 将继续检查下一条规则， 如果该数据包不符合链中任一条规则，iptables 就会根据该链预先定义的默认策略来处理数据包。  PREROUTING 链 内核根据数据包目的 IP 判断是否需要转发出去\nINPUT 链 处理来自外部的数据\nOUTPUT 链 处理向外发送的数据\nFORWARD 链 将数据转发到本机的其他网卡设备上。\nPOSTROUTING 链  iptables 调用链  条件匹配    短命令 长命令       -i \u0026ndash;in-interface 网络接口名 指定数据包从哪个网络接口进入   -o \u0026ndash;out-interface 网络接口名 指定数据包从哪个网络接口输出   -p \u0026mdash;proto 协议类型 指定数据包匹配的协议，如 TCP、UDP 和 ICMP 等   -s \u0026ndash;source 源地址或子网 指定数据包匹配的源地址    \u0026ndash;sport 源端口号 指定数据包匹配的源端口号    \u0026ndash;dport 目的端口号 指定数据包匹配的目的端口号   -m \u0026ndash;match 匹配的模块 指定数据包规则所使用的过滤模块     目标动作或跳转 ACCEPT、REJECT、DROP、REDIRECT 、MASQUERADE\n还有 LOG、ULOG、DNAT、RETURN、TOS、SNAT、MIRROR、QUEUE、TTL、MARK\n 保存 iptables 修改 方法一：service iptables save\n方法二：\n  修改 /etc/sysconfig/iptables-config\n  将里面的 IPTABLES_SAVE_ON_STOP=\u0026quot;no\u0026rdquo;, 改为 \u0026ldquo;yes\u0026rdquo;\n  这样每次服务在停止之前会自动将现有的规则保存在 /etc/sysconfig/iptables 这个文件中去。\n   教程 超级详细的 iptable 教程文档 常见 iptables 使用规则场景整理 "});index.add({'id':13,'href':'/study-network/docs/basic/practice/libevent/','title':"libevent",'content':"libevent libevent/libevent Event notification library https://libevent.org\n支持多种 I/O 多路复用技术，epoll、poll、dev/poll、select 和 kqueue 等\n reactor 参考  Libevent 深入浅出  "});index.add({'id':14,'href':'/study-network/docs/basic/protocol/tls/mtls/','title':"mTLS",'content':"mTLS "});index.add({'id':15,'href':'/study-network/docs/basic/cmd/netfilter/','title':"netfilter",'content':"netfilter "});index.add({'id':16,'href':'/study-network/docs/basic/practice/select/','title':"select",'content':"select "});index.add({'id':17,'href':'/study-network/docs/basic/protocol/tcp/','title':"TCP",'content':"TCP "});index.add({'id':18,'href':'/study-network/docs/basic/protocol/tls/','title':"TLS",'content':"TLS "});index.add({'id':19,'href':'/study-network/docs/basic/protocol/udp/','title':"UDP",'content':"UDP "});index.add({'id':20,'href':'/study-network/docs/appendix/attention/','title':"关注",'content':"关注 其他 netty/netty Netty project - an event-driven asynchronous network application framework http://netty.io/\nlibuv/libuv Cross-platform asynchronous I/O https://libuv.org/\npanjf2000/gnet gnet 是一个基于事件驱动的高性能和轻量级网络框架。它直接使用 epoll 和 kqueue 系统调用而非标准 Go 网络包：net 来构建网络应用，它的工作原理类似两个开源的网络库：netty/netty 和 libuv/libuv 。\ngnet 设计开发的初衷不是为了取代 Go 的标准网络库：net，而是为了创造出一个类似于 antirez/redis 、haproxy/haproxy 能高效处理网络包的 Go 语言网络服务器框架。\ngnet 的卖点在于它是一个高性能、轻量级、非阻塞的纯 Go 实现的传输层（TCP/UDP/Unix Domain Socket）网络框架，开发者可以使用 gnet 来实现自己的应用层网络协议 (HTTP、RPC、Redis、WebSocket 等等)，从而构建出自己的应用层网络应用：比如在 gnet 上实现 HTTP 协议就可以创建出一个 HTTP 服务器 或者 Web 开发框架，实现 Redis 协议就可以创建出自己的 Redis 服务器等等。\ngnet 衍生自另一个项目：tidwall/evio ，但拥有更丰富的功能特性，且性能远胜之。\ntidwall/evio Fast event-loop networking for Go\n"});index.add({'id':21,'href':'/study-network/docs/basic/cmd/','title':"命令",'content':"命令 "});index.add({'id':22,'href':'/study-network/docs/basic/protocol/','title':"协议",'content':"协议 "});index.add({'id':23,'href':'/study-network/docs/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':24,'href':'/study-network/docs/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':25,'href':'/study-network/docs/','title':"Docs",'content':""});})();