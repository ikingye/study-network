<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta name="generator" content="Hugo 0.99.1" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="TCP #  TCP 报文格式 #   序号：Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq&#43;1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：  URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。    三次握手 #  四次挥手 #  实际中还会出现同时发起主动关闭的情况
 TCP 有限状态机 #  The TCP Finite State Machine (FSM)

 TCP 状态变迁图 #  
 TCP 是全双工的 #   TCP 的 RTT 算法 #  经典算法（RFC793） #    首先，先采样 RTT，记下最近好几次的 RTT 值。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="TCP" />
<meta property="og:description" content="TCP #  TCP 报文格式 #   序号：Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq&#43;1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：  URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。    三次握手 #  四次挥手 #  实际中还会出现同时发起主动关闭的情况
 TCP 有限状态机 #  The TCP Finite State Machine (FSM)

 TCP 状态变迁图 #  
 TCP 是全双工的 #   TCP 的 RTT 算法 #  经典算法（RFC793） #    首先，先采样 RTT，记下最近好几次的 RTT 值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kingye.me/study-network/docs/basic/protocol/tcp/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2020-12-16T21:06:45+08:00" />

<title>TCP | 网络学习笔记</title>
<link rel="manifest" href="/study-network/manifest.json">
<link rel="icon" href="/study-network/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/study-network/book.min.e3d401e975fe9e04a41f82b0c90be4c8773f2541f197dba3ff2ae80293cb78c2.css" integrity="sha256-49QB6XX&#43;ngSkH4KwyQvkyHc/JUHxl9uj/yroApPLeMI=">
<script defer src="/study-network/en.search.min.47bff0c6fbeb29db50f7298a4c98ff8ec049966950e7965391cf14e9ada034a3.js" integrity="sha256-R7/wxvvrKdtQ9ymKTJj/jsBJlmlQ55ZTkc8U6a2gNKM="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/study-network"><span>网络学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>



<ul>
  <li><a href="https://kingye.me" target="_blank" rel="noopener noreferrer">博客</a></li>
  <li><a href="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200417021727.png" target="_blank" rel="noopener noreferrer">公众号</a></li>
  <li><a href="https://github.com/ikingye" target="_blank" rel="noopener noreferrer">Github</a></li>
  <li><a href="https://weibo.com/kingyip15215" target="_blank" rel="noopener noreferrer">微博</a></li>
  <li><a href="https://www.zhihu.com/people/wutongyip" target="_blank" rel="noopener noreferrer">知乎</a></li>
</ul>
<hr />








  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>第一部分 基础入门</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5275395c0a3eae639bd300e7513716ab" class="toggle"  />
    <label for="section-5275395c0a3eae639bd300e7513716ab" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/basic/cmd/" class="">1.1 命令</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d327945b8835d0c83427b6a0449d59a7" class="toggle"  />
    <label for="section-d327945b8835d0c83427b6a0449d59a7" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/basic/cmd/curl/" class="">curl</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-76f2a67c5fff841c9adeef4ded43d468" class="toggle"  />
    <label for="section-76f2a67c5fff841c9adeef4ded43d468" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/basic/cmd/iptables/" class="">iptables</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-88864e1edfa4d68174568e8efd69522f" class="toggle"  />
    <label for="section-88864e1edfa4d68174568e8efd69522f" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/basic/cmd/netfilter/" class="">netfilter</a>
    </label>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-054c01723ce2098e7389d637924803ae" class="toggle" checked />
    <label for="section-054c01723ce2098e7389d637924803ae" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/basic/protocol/" class="">1.2 协议</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://kingye.me/study-network/docs/basic/protocol/tcp/" class=" active">TCP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://kingye.me/study-network/docs/basic/protocol/udp/" class="">UDP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://kingye.me/study-network/docs/basic/protocol/dns/" class="">DNS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://kingye.me/study-network/docs/basic/protocol/http/" class="">HTTP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://kingye.me/study-network/docs/basic/protocol/ssl/" class="">SSL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ec0bdce3a8736f8caf54a8616d5a75d6" class="toggle"  />
    <label for="section-ec0bdce3a8736f8caf54a8616d5a75d6" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/basic/protocol/websocket/" class="">WebSocket</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://kingye.me/study-network/docs/basic/protocol/https/" class="">HTTPs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>第二部分 进阶实战</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-86db07aee190a4e8fd024783caee6bb8" class="toggle"  />
    <label for="section-86db07aee190a4e8fd024783caee6bb8" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/code/" class="">2.1 网络编程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0117ee697645fb3af0c8c2ad971ca81d" class="toggle"  />
    <label for="section-0117ee697645fb3af0c8c2ad971ca81d" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/code/spec/" class="">编程规范</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-58a436c59b44740cf9163a26ca931c1f" class="toggle"  />
    <label for="section-58a436c59b44740cf9163a26ca931c1f" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/code/epoll/" class="">epoll</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-7d7a75cd16fb8c20085182edb8c72afd" class="toggle"  />
    <label for="section-7d7a75cd16fb8c20085182edb8c72afd" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/code/libevent/" class="">libevent</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0f3c50ccdc3e83c9dfb6228b4714841d" class="toggle"  />
    <label for="section-0f3c50ccdc3e83c9dfb6228b4714841d" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/code/select/" class="">select</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a784c11a68fca5d10a4ba33481b6822d" class="toggle"  />
    <label for="section-a784c11a68fca5d10a4ba33481b6822d" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/tool/" class="">2.2 网络工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-80e54258fb2197a0a33f5da69717dee6" class="toggle"  />
    <label for="section-80e54258fb2197a0a33f5da69717dee6" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/advanced/tool/wireshark/" class="">Wireshark</a>
    </label>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>第三部分 设计与实现</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d275f0b38ebbe8f17652f03c31910fe4" class="toggle"  />
    <label for="section-d275f0b38ebbe8f17652f03c31910fe4" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/code/stack/" class="">3.1 协议栈</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>第四部分 附录</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2d181cd3861ca7652e852d22b5c3ff21" class="toggle"  />
    <label for="section-2d181cd3861ca7652e852d22b5c3ff21" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/appendix/tutorial/" class="">4.1 教程</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1141a4bba37d01f14e63bf36d9c7071d" class="toggle"  />
    <label for="section-1141a4bba37d01f14e63bf36d9c7071d" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/appendix/interview/" class="">4.2 面试题</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c743998336860c656367010fc7573b86" class="toggle"  />
    <label for="section-c743998336860c656367010fc7573b86" class="flex justify-between">
      <a href="https://kingye.me/study-network/docs/appendix/attention/" class="">4.3 关注项目</a>
    </label>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














<hr />
<ul>
  <li><a href="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200417022040.png" target="_blank" rel="noopener noreferrer">微信</a></li>
  <li><a href="https://qm.qq.com/cgi-bin/qm/qr?k=EUhzg0UwUksxpQnwEmPngRLezlC6qrnn&jump_from=webapi" target="_blank" rel="noopener noreferrer"><img src="//pub.idqqimg.com/wpa/images/group.png"></a></li>
</ul>


</nav>




  <script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/study-network/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>TCP</strong>

  <label for="toc-control">
    
    <img src="/study-network/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#tcp-报文格式">TCP 报文格式</a></li>
    <li><a href="#三次握手">三次握手</a></li>
    <li><a href="#四次挥手">四次挥手</a></li>
    <li><a href="#tcp-有限状态机">TCP 有限状态机</a></li>
    <li><a href="#tcp-状态变迁图">TCP 状态变迁图</a></li>
    <li><a href="#tcp-是全双工的">TCP 是全双工的</a></li>
    <li><a href="#tcp-的-rtt-算法">TCP 的 RTT 算法</a>
      <ul>
        <li><a href="#经典算法rfc793httptoolsietforghtmlrfc793">经典算法（<a href="http://tools.ietf.org/html/rfc793">RFC793</a>）</a></li>
        <li><a href="#karn--partridge-算法">Karn / Partridge 算法</a></li>
        <li><a href="#jacobson--karels-算法">Jacobson / Karels 算法</a></li>
      </ul>
    </li>
    <li><a href="#tcp-滑动窗口">TCP 滑动窗口</a>
      <ul>
        <li><a href="#发送方的滑动窗口">发送方的滑动窗口</a></li>
        <li><a href="#接受端控制发送端的图示">接受端控制发送端的图示</a></li>
      </ul>
    </li>
    <li><a href="#tcp-的拥塞处理">TCP 的拥塞处理</a>
      <ul>
        <li><a href="#慢热启动算法--slow-start">慢热启动算法 – Slow Start</a></li>
        <li><a href="#拥塞避免算法--congestion-avoidance">拥塞避免算法 – Congestion Avoidance</a></li>
        <li><a href="#拥塞状态时的算法">拥塞状态时的算法</a></li>
        <li><a href="#快速恢复算法--fast-recovery">快速恢复算法 – Fast Recovery</a></li>
        <li><a href="#fack-算法">FACK 算法</a></li>
      </ul>
    </li>
    <li><a href="#syn-攻击">SYN 攻击</a>
      <ul>
        <li><a href="#解决">解决</a></li>
      </ul>
    </li>
    <li><a href="#问答">问答</a>
      <ul>
        <li><a href="#为什么建立连接是三次握手而关闭连接却是四次挥手呢">为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</a></li>
        <li><a href="#单台服务器并发-tcp-连接数到底可以有多少">单台服务器并发 TCP 连接数到底可以有多少？</a>
          <ul>
            <li><a href="#文件句柄限制">文件句柄限制</a>
              <ul>
                <li><a href="#进程限制">进程限制</a></li>
                <li><a href="#全局限制">全局限制</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#为什么服务总会抛出一个-connet-reset-by-peer">为什么服务总会抛出一个 <code>connet reset by peer</code>？</a></li>
        <li><a href="#出现大量-time_wait-状态怎么办">出现大量 time_wait 状态怎么办？</a>
          <ul>
            <li><a href="#time_wait-是怎么产生的">TIME_WAIT 是怎么产生的？</a>
              <ul>
                <li><a href="#连接关闭的过程">连接关闭的过程</a></li>
                <li><a href="#time_wait-只会出现在主动断开连接的一方">TIME_WAIT 只会出现在主动断开连接的一方</a></li>
              </ul>
            </li>
            <li><a href="#大量-time_wait-造成的影响">大量 TIME_WAIT 造成的影响</a></li>
            <li><a href="#排查">排查</a>
              <ul>
                <li><a href="#查看-tcp-各个状态的数量">查看 TCP 各个状态的数量</a></li>
                <li><a href="#tcp-状态含义">TCP 状态含义</a></li>
                <li><a href="#统计-time_wait-连接的本地地址">统计 TIME_WAIT 连接的本地地址</a></li>
              </ul>
            </li>
            <li><a href="#如何尽量处理-timewait-过多的问题">如何尽量处理 TIMEWAIT 过多的问题？</a>
              <ul>
                <li><a href="#修改内核文件-etcsysctlconf">修改内核文件 /etc/sysctl.conf</a></li>
                <li><a href="#nginx-配置问题">nginx 配置问题</a>
                  <ul>
                    <li><a href="#proxy_pass-与-fastcgi_pass-的区别">proxy_pass 与 fastcgi_pass 的区别</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#为什么要有-time_wait-状态">为什么要有 TIME_WAIT 状态？</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article id="article" class="markdown"><h1 id="tcp">
  TCP
  <a class="anchor" href="#tcp">#</a>
</h1>
<h2 id="tcp-报文格式">
  TCP 报文格式
  <a class="anchor" href="#tcp-%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f">#</a>
</h2>
<p><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525230243.png" alt="" /></p>
<ul>
<li>序号：Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>
<li>确认序号：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。</li>
<li>标志位：共 6 个，即 <code>URG</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>SYN</code>、<code>FIN</code> 等，具体含义如下：
<ul>
<li><code>URG</code>：紧急指针（urgent pointer）有效。</li>
<li><code>ACK</code>：确认序号有效。</li>
<li><code>PSH</code>：接收方应该尽快将这个报文交给应用层。</li>
<li><code>RST</code>：重置连接。</li>
<li><code>SYN</code>：发起一个新连接。</li>
<li><code>FIN</code>：释放一个连接。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525230718.png" alt="" /></p>
<h2 id="三次握手">
  三次握手
  <a class="anchor" href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b">#</a>
</h2>
<p><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525231319.png" alt="" /></p>
<h2 id="四次挥手">
  四次挥手
  <a class="anchor" href="#%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b">#</a>
</h2>
<p><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525231259.png" alt="" /></p>
<p>实际中还会出现同时发起主动关闭的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525231407.png" alt="" /></p>
<hr>
<h2 id="tcp-有限状态机">
  TCP 有限状态机
  <a class="anchor" href="#tcp-%e6%9c%89%e9%99%90%e7%8a%b6%e6%80%81%e6%9c%ba">#</a>
</h2>
<p>The TCP Finite State Machine (FSM)</p>
<p><a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525231924.png" alt="" /></a></p>
<hr>
<h2 id="tcp-状态变迁图">
  TCP 状态变迁图
  <a class="anchor" href="#tcp-%e7%8a%b6%e6%80%81%e5%8f%98%e8%bf%81%e5%9b%be">#</a>
</h2>
<p><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/#h18_6"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525235421.png" alt="" /></a></p>
<hr>
<h2 id="tcp-是全双工的">
  TCP 是全双工的
  <a class="anchor" href="#tcp-%e6%98%af%e5%85%a8%e5%8f%8c%e5%b7%a5%e7%9a%84">#</a>
</h2>
<hr>
<h2 id="tcp-的-rtt-算法">
  TCP 的 RTT 算法
  <a class="anchor" href="#tcp-%e7%9a%84-rtt-%e7%ae%97%e6%b3%95">#</a>
</h2>
<h3 id="经典算法rfc793httptoolsietforghtmlrfc793">
  经典算法（<a href="http://tools.ietf.org/html/rfc793">RFC793</a>）
  <a class="anchor" href="#%e7%bb%8f%e5%85%b8%e7%ae%97%e6%b3%95rfc793httptoolsietforghtmlrfc793">#</a>
</h3>
<ol>
<li>
<p>首先，先采样 RTT，记下最近好几次的 RTT 值。</p>
</li>
<li>
<p>然后做平滑计算 SRTT（<code>Smoothed RTT</code>），公式为：</p>
<p><code>SRTT = (α * SRTT) + ((1- α) * RTT)</code></p>
<p>其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 <code>Exponential weighted moving average</code>，中文叫：<code>加权移动平均</code></p>
</li>
<li>
<p>开始计算 RTO。公式如下：</p>
<p><code>RTO = min [UBOUND, max [LBOUND, (β * SRTT)]]</code></p>
</li>
</ol>
<p>其中：</p>
<ul>
<li>UBOUND 是最大的 timeout 时间，上限值</li>
<li>LBOUND 是最小的 timeout 时间，下限值</li>
<li>β 值一般在 1.3 到 2.0 之间。</li>
</ul>
<h3 id="karn--partridge-算法">
  Karn / Partridge 算法
  <a class="anchor" href="#karn--partridge-%e7%ae%97%e6%b3%95">#</a>
</h3>
<h3 id="jacobson--karels-算法">
  Jacobson / Karels 算法
  <a class="anchor" href="#jacobson--karels-%e7%ae%97%e6%b3%95">#</a>
</h3>
<hr>
<h2 id="tcp-滑动窗口">
  TCP 滑动窗口
  <a class="anchor" href="#tcp-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3">#</a>
</h2>
<p>TCP 缓冲区的数据结构</p>
<p><a href="http://www.52im.net/thread-515-1-1.html"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525232814.png" alt="" /></a></p>
<p>接收端在给发送端回 ACK 中会汇报自己的 <code>AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1</code>;</p>
<p>发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理</p>
<h3 id="发送方的滑动窗口">
  发送方的滑动窗口
  <a class="anchor" href="#%e5%8f%91%e9%80%81%e6%96%b9%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3">#</a>
</h3>
<p><a href="http://www.52im.net/thread-515-1-1.html"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525233037.png" alt="" /></a></p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li><code>#1</code> 已收到 ack 确认的数据。</li>
<li><code>#2</code> 发还没收到 ack 的。</li>
<li><code>#3</code> 在窗口中还没有发出的（接收方还有空间）。</li>
<li><code>#4</code> 窗口以外的数据（接收方没空间）</li>
</ul>
<h3 id="接受端控制发送端的图示">
  接受端控制发送端的图示
  <a class="anchor" href="#%e6%8e%a5%e5%8f%97%e7%ab%af%e6%8e%a7%e5%88%b6%e5%8f%91%e9%80%81%e7%ab%af%e7%9a%84%e5%9b%be%e7%a4%ba">#</a>
</h3>
<p><a href="http://www.52im.net/thread-515-1-1.html"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525233340.png" alt="" /></a></p>
<h2 id="tcp-的拥塞处理">
  TCP 的拥塞处理
  <a class="anchor" href="#tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e5%a4%84%e7%90%86">#</a>
</h2>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h3 id="慢热启动算法--slow-start">
  慢热启动算法 – Slow Start
  <a class="anchor" href="#%e6%85%a2%e7%83%ad%e5%90%af%e5%8a%a8%e7%ae%97%e6%b3%95--slow-start">#</a>
</h3>
<p>慢启动的算法如下 (cwnd 全称 Congestion Window)：</p>
<ul>
<li>连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。</li>
<li>每当收到一个 ACK，cwnd++; 呈线性上升</li>
<li>每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升</li>
<li>还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入 “拥塞避免算法”</li>
</ul>
<p><a href="http://www.52im.net/thread-515-1-1.html"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525234415.png" alt="" /></a></p>
<h3 id="拥塞避免算法--congestion-avoidance">
  拥塞避免算法 – Congestion Avoidance
  <a class="anchor" href="#%e6%8b%a5%e5%a1%9e%e9%81%bf%e5%85%8d%e7%ae%97%e6%b3%95--congestion-avoidance">#</a>
</h3>
<p>ssthresh（slow start threshold）是一个上限，
当 cwnd &gt;= ssthresh 时，就会进入 “拥塞避免算法”。</p>
<p>一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下：</p>
<ul>
<li>收到一个 ACK 时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个 RTT 时，cwnd = cwnd + 1</li>
</ul>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h3 id="拥塞状态时的算法">
  拥塞状态时的算法
  <a class="anchor" href="#%e6%8b%a5%e5%a1%9e%e7%8a%b6%e6%80%81%e6%97%b6%e7%9a%84%e7%ae%97%e6%b3%95">#</a>
</h3>
<h3 id="快速恢复算法--fast-recovery">
  快速恢复算法 – Fast Recovery
  <a class="anchor" href="#%e5%bf%ab%e9%80%9f%e6%81%a2%e5%a4%8d%e7%ae%97%e6%b3%95--fast-recovery">#</a>
</h3>
<h3 id="fack-算法">
  FACK 算法
  <a class="anchor" href="#fack-%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>更多拥塞控制请参考论文<a href="http://ee.lbl.gov/papers/congavoid.pdf">《Congestion Avoidance and Control》</a>(PDF)</p>
<hr>
<h2 id="syn-攻击">
  SYN 攻击
  <a class="anchor" href="#syn-%e6%94%bb%e5%87%bb">#</a>
</h2>
<p>在三次握手过程中，Server 发送 SYN-ACK 之后，收到 Client 的 ACK 之前的 TCP 连接称为半连接（half-open connect），</p>
<p>此时 Server 处于 SYN_RCVD 状态，</p>
<p>当收到 ACK 后，Server 转入 ESTABLISHED 状态。</p>
<p>SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 回复确认包，并等待 Client 的确认，
由于源地址是不存在的，因此，Server 需要不断重发直至超时，</p>
<p>这些伪造的 SYN 包将产时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p>
<p>SYN 攻击时一种典型的 DDOS 攻击，</p>
<p>检测 SYN 攻击的方式非常简单，即当 Server 上有大量半连接状态且源 IP 地址是随机的，则可以断定遭到 SYN 攻击了，</p>
<p>使用如下命令可以让之现行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ netstat -nap | grep SYN_RECV
</span></span></code></pre></div><p>于是，server 端如果在一定时间内没有收到的 TCP 会重发 SYN-ACK。
在 Linux 下，默认重试次数为 5 次，
重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s，
第 5 次发出后还要等 32s 都知道第 5 次也超时了，
所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP 才会把断开这个连接。</p>
<h3 id="解决">
  解决
  <a class="anchor" href="#%e8%a7%a3%e5%86%b3">#</a>
</h3>
<p>对于正常的请求，你应该调整三个 TCP 参数可供你选择，</p>
<ul>
<li><code>tcp_synack_retries</code> 可以用他来减少重试次数</li>
<li><code>tcp_max_syn_backlog</code> 可以增大 SYN 连接数</li>
<li><code>tcp_abort_on_overflow</code> 处理不过来干脆就直接拒绝连接了</li>
</ul>
<hr>
<h2 id="问答">
  问答
  <a class="anchor" href="#%e9%97%ae%e7%ad%94">#</a>
</h2>
<h3 id="为什么建立连接是三次握手而关闭连接却是四次挥手呢">
  为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e6%98%af%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e8%80%8c%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5%e5%8d%b4%e6%98%af%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e5%91%a2">#</a>
</h3>
<p>因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p>
<p>而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，
因此，己方 ACK 和 FIN 一般都会分开发送。</p>
<p>对于 4 次挥手：其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。</p>
<p>下图是双方同时断连接的示意图</p>
<p><a href="http://www.52im.net/thread-513-1-1.html"><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200525232139.png" alt="" /></a></p>
<h3 id="单台服务器并发-tcp-连接数到底可以有多少">
  单台服务器并发 TCP 连接数到底可以有多少？
  <a class="anchor" href="#%e5%8d%95%e5%8f%b0%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%b9%b6%e5%8f%91-tcp-%e8%bf%9e%e6%8e%a5%e6%95%b0%e5%88%b0%e5%ba%95%e5%8f%af%e4%bb%a5%e6%9c%89%e5%a4%9a%e5%b0%91">#</a>
</h3>
<p>操作系统上端口号 1024 以下是系统保留的，从 1024-65535 是用户使用的。</p>
<p>由于每个 TCP 连接都要占一个端口号，所以我们最多可以有 60000 多个并发连接？</p>
<p>并不是的。这个是客户端的限制，而不是服务端。</p>
<p>系统用一个 4 四元组来唯一标识一个 TCP 连接：<code>{local ip, local port, remote ip, remote port}</code>。</p>
<p>服务端实际只使用了 bind 时这一个端口，说明端口号 65535 并不是并发量的限制</p>
<p>最大 tcp 连接为<code>客户端 ip 数 × 客户端 port 数</code>，</p>
<p>对 IPV4，不考虑 ip 地址分类等因素，最大 tcp 连接数约为 2 的 32 次方（ip 数）×2 的 16 次方（port 数），</p>
<p>也就是 server 端单机最大 tcp 连接数理论上约为 <code>2 的 48 次方</code>。</p>
<p>当然实际上单机并发连接数肯定要受硬件资源（内存）、网络资源（带宽）的限制。</p>
<h4 id="文件句柄限制">
  文件句柄限制
  <a class="anchor" href="#%e6%96%87%e4%bb%b6%e5%8f%a5%e6%9f%84%e9%99%90%e5%88%b6">#</a>
</h4>
<p>每一个 tcp 连接都要占一个文件描述符，</p>
<p>一旦这个文件描述符使用完了，新的连接到来返回给我们的错误是 <code>“Socket/File:Can't open so many files”</code>。</p>
<h5 id="进程限制">
  进程限制
  <a class="anchor" href="#%e8%bf%9b%e7%a8%8b%e9%99%90%e5%88%b6">#</a>
</h5>
<p>执行 <code>ulimit -n</code> 输出 1024，说明对于一个进程而言最多只能打开 1024 个文件</p>
<ul>
<li>用户退出后失效：<code>ulimit -n 1000000</code></li>
<li>重启后失效：编辑 /etc/security/limits.conf 文件
<ul>
<li>soft nofile 1000000</li>
<li>hard nofile 1000000</li>
</ul>
</li>
<li>永久修改：编辑 /etc/rc.local，在其后添加如下内容
<ul>
<li>ulimit -SHn 1000000</li>
</ul>
</li>
</ul>
<h5 id="全局限制">
  全局限制
  <a class="anchor" href="#%e5%85%a8%e5%b1%80%e9%99%90%e5%88%b6">#</a>
</h5>
<p>执行 cat /proc/sys/fs/file-nr 输出 9344 0 592026，分别为：</p>
<ol>
<li>已经分配的文件句柄数，</li>
<li>已经分配但没有使用的文件句柄数，</li>
<li>最大文件句柄数。</li>
</ol>
<p>但在 kernel 2.6 版本中第二项的值总为 0，这并不是一个错误，它实际上意味着已经分配的文件描述符无一浪费的都已经被使用了 。</p>
<p>我们可以把这个数值改大些，用 root 权限修改 /etc/sysctl.conf 文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>fs.file-max <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>net.ipv4.ip_conntrack_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>net.ipv4.netfilter.ip_conntrack_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>
</span></span></code></pre></div><h3 id="为什么服务总会抛出一个-connet-reset-by-peer">
  为什么服务总会抛出一个 <code>connet reset by peer</code>？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%8d%e5%8a%a1%e6%80%bb%e4%bc%9a%e6%8a%9b%e5%87%ba%e4%b8%80%e4%b8%aa-connet-reset-by-peer">#</a>
</h3>
<p>主动关闭方直接发送了一个 <code>RST flags</code>，而<code>非 FIN</code>，就终止连接了。</p>
<hr>
<h3 id="出现大量-time_wait-状态怎么办">
  出现大量 time_wait 状态怎么办？
  <a class="anchor" href="#%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f-time_wait-%e7%8a%b6%e6%80%81%e6%80%8e%e4%b9%88%e5%8a%9e">#</a>
</h3>
<p>TIME_WAIT 状态也称为 <code>2MSL</code> 等待状态。
每个具体 TCP 实现必须选择一个报文段最大生存时间 <code>MSL</code>（<code>Maximum Segment Lifetime</code>）。
它是任何报文段被丢弃前在网络内的最长时间。</p>
<p>我们知道这个时间是有限的，因为 TCP 报文段以 IP 数据报在网络内传输，而 IP 数据报则有限制其生存时间的 TTL 字段。</p>
<p>RFC 793 [Postel 1981c] 指出 <code>MSL</code> 为 2 分钟。
然而，实现中的常用值是 30 秒，1 分钟，或 2 分钟。</p>
<p>对 <code>IP 数据报</code> <code>TTL</code> 的限制是基于<strong>跳数</strong>，而不是定时器。</p>
<h4 id="time_wait-是怎么产生的">
  TIME_WAIT 是怎么产生的？
  <a class="anchor" href="#time_wait-%e6%98%af%e6%80%8e%e4%b9%88%e4%ba%a7%e7%94%9f%e7%9a%84">#</a>
</h4>
<h5 id="连接关闭的过程">
  连接关闭的过程
  <a class="anchor" href="#%e8%bf%9e%e6%8e%a5%e5%85%b3%e9%97%ad%e7%9a%84%e8%bf%87%e7%a8%8b">#</a>
</h5>
<p><img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200409000158.png" alt="" /></p>
<ul>
<li>主动关闭连接的一方，调用 <code>close()</code>；协议层发送 FIN 包</li>
<li>被动关闭的一方收到 FIN 包后，协议层回复 ACK；然后<strong>被动关闭</strong>的一方，进入 <code>CLOSE_WAIT</code> 状态；主动关闭的一方等待对方关闭，则进入 <code>FIN_WAIT_2</code> 状态</li>
<li>被动关闭的一方在完成所有数据发送后，调用 <code>close()</code> 操作，协议层发送 FIN 包给主动关闭的一方，等待对方的 ACK，被动关闭的一方进入 <code>LAST_ACK</code> 状态</li>
<li>主动关闭的一方收到 FIN 包，协议层回复 ACK，<strong>主动关闭连</strong>接的一方进入 <code>TIME_WAIT</code> 状态；而被动关闭的一方，进入 <code>CLOSED</code> 状态</li>
<li>等待 <code>2MSL</code> 时间，主动关闭的一方，结束 TIME_WAIT，进入 <code>CLOSED</code> 状态</li>
</ul>
<h5 id="time_wait-只会出现在主动断开连接的一方">
  TIME_WAIT 只会出现在主动断开连接的一方
  <a class="anchor" href="#time_wait-%e5%8f%aa%e4%bc%9a%e5%87%ba%e7%8e%b0%e5%9c%a8%e4%b8%bb%e5%8a%a8%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5%e7%9a%84%e4%b8%80%e6%96%b9">#</a>
</h5>
<h4 id="大量-time_wait-造成的影响">
  大量 TIME_WAIT 造成的影响
  <a class="anchor" href="#%e5%a4%a7%e9%87%8f-time_wait-%e9%80%a0%e6%88%90%e7%9a%84%e5%bd%b1%e5%93%8d">#</a>
</h4>
<ul>
<li>在<strong>高并发短连接</strong>的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。
<ul>
<li><strong>短连接</strong>表示 “业务处理 + 传输数据的时间 远远小于 TIMEWAIT 超时的时间” 的连接</li>
<li><strong>高并发</strong>可以让服务器在短时间范围内同时占用大量端口，
<ul>
<li>而端口有个 0~65535 的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。</li>
</ul>
</li>
</ul>
<ul>
<li>在实际业务场景中，一般长连接对应的业务的并发量并不会很高</li>
<li>这些端口都是服务器临时分配，无法用 <code>SO_REUSEADDR</code> 选项解决这个问题</li>
</ul>
</li>
<li>内存
<ul>
<li>内核里有一个保存所有连接的 hash table</li>
<li>不同的内核对这个 hash table 的大小设置不同，你可以通过 dmesg 命令去找到你的内核设置的大小</li>
<li>还有一个 hash table 用来保存所有的 bound ports，主要用于可以快速的找到一个可用的端口或者随机端口</li>
<li>不过占用内存很少很少。 一个 tcp socket 占用不到 4k。1 万条 TIME_WAIT 的连接，也就多消耗 1M 左右的内存</li>
</ul>
</li>
<li>CPU
<ul>
<li>每次找到一个随机端口，还是需要遍历一遍 bound ports 的吧，这必然需要一些 CPU 时间。</li>
</ul>
</li>
<li>源端口数量 (net.ipv4.ip_local_port_range)</li>
<li>TIME_WAIT bucket 数量 (net.ipv4.tcp_max_tw_buckets)</li>
<li>文件描述符数量 (max open file)
<ul>
<li>一个 socket 占用一个文件描述符</li>
</ul>
</li>
</ul>
<h4 id="排查">
  排查
  <a class="anchor" href="#%e6%8e%92%e6%9f%a5">#</a>
</h4>
<h5 id="查看-tcp-各个状态的数量">
  查看 TCP 各个状态的数量
  <a class="anchor" href="#%e6%9f%a5%e7%9c%8b-tcp-%e5%90%84%e4%b8%aa%e7%8a%b6%e6%80%81%e7%9a%84%e6%95%b0%e9%87%8f">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>netstat -ant | awk <span style="color:#e6db74">&#39;/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}&#39;</span> | sort -rn -k2
</span></span></code></pre></div><h5 id="tcp-状态含义">
  TCP 状态含义
  <a class="anchor" href="#tcp-%e7%8a%b6%e6%80%81%e5%90%ab%e4%b9%89">#</a>
</h5>
<table>
<thead>
<tr>
<th>TCP 状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>LISTEN</td>
<td>服务器在等待进入呼叫</td>
</tr>
<tr>
<td>SYN_RECV</td>
<td>一个连接请求已经到达，等待确认</td>
</tr>
<tr>
<td>SYN_SENT</td>
<td>应用已经开始，打开一个连接</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>正常数据传输状态</td>
</tr>
<tr>
<td>FIN_WAIT1</td>
<td>应用说它已经完成</td>
</tr>
<tr>
<td>FIN_WAIT2</td>
<td>另一边已同意释放</td>
</tr>
<tr>
<td>ITMED_WAIT</td>
<td>等待所有分组死掉</td>
</tr>
<tr>
<td>LAST_ACK</td>
<td>等待所有分组死掉</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>另一边已初始化一个释放</td>
</tr>
<tr>
<td>CLOSING</td>
<td>两边同时尝试关闭</td>
</tr>
<tr>
<td>CLOSED</td>
<td>无连接是活动的或正在进行</td>
</tr>
</tbody>
</table>
<h5 id="统计-time_wait-连接的本地地址">
  统计 TIME_WAIT 连接的本地地址
  <a class="anchor" href="#%e7%bb%9f%e8%ae%a1-time_wait-%e8%bf%9e%e6%8e%a5%e7%9a%84%e6%9c%ac%e5%9c%b0%e5%9c%b0%e5%9d%80">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>netstat -an | grep TIME_WAIT | awk <span style="color:#e6db74">&#39;{print $4}&#39;</span> | sort | uniq -c | sort -rn -k1 | head
</span></span></code></pre></div><h4 id="如何尽量处理-timewait-过多的问题">
  如何尽量处理 TIMEWAIT 过多的问题？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%b0%bd%e9%87%8f%e5%a4%84%e7%90%86-timewait-%e8%bf%87%e5%a4%9a%e7%9a%84%e9%97%ae%e9%a2%98">#</a>
</h4>
<h5 id="修改内核文件-etcsysctlconf">
  修改内核文件 /etc/sysctl.conf
  <a class="anchor" href="#%e4%bf%ae%e6%94%b9%e5%86%85%e6%a0%b8%e6%96%87%e4%bb%b6-etcsysctlconf">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>net.ipv4.tcp_syncookies <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> 表示开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 cookies 来处理，可防范少量 SYN 攻击，默认为 0，表示关闭；
</span></span><span style="display:flex;"><span>net.ipv4.tcp_tw_reuse <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭；
</span></span><span style="display:flex;"><span>net.ipv4.tcp_tw_recycle <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> 表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收，默认为 0，表示关闭。
</span></span><span style="display:flex;"><span>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间
</span></span></code></pre></div><p>然后执行 /sbin/sysctl -p 让参数生效。</p>
<p>/etc/sysctl.conf 是一个允许改变正在运行中的 Linux 系统的接口，它包含一些 TCP/IP 堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。</p>
<p>简单来说，就是打开系统的 TIMEWAIT 重用和快速回收。</p>
<p>如果以上配置调优后性能还不理想，可继续修改一下配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>net.ipv4.tcp_keepalive_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">1200</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span>
</span></span><span style="display:flex;"><span>net.ipv4.ip_local_port_range <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span> <span style="color:#ae81ff">65000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span>
</span></span><span style="display:flex;"><span>net.ipv4.tcp_max_syn_backlog <span style="color:#f92672">=</span> <span style="color:#ae81ff">8192</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span>
</span></span><span style="display:flex;"><span>net.ipv4.tcp_max_tw_buckets <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#表示系统同时保持 TIME_WAIT 套接字的最大数量，如果超过这个数字， TIME_WAIT 套接字将立刻被清除并打印警告信息。</span>
</span></span><span style="display:flex;"><span>默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少 TIME_WAIT 套接字数量，但是对于 Squid，效果却不大。此项参数可以控制 TIME_WAIT 套接字的最大数量，避免Squid服务器被大量的 TIME_WAIT 套接字拖死。
</span></span></code></pre></div><p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/dadonggg/p/8778318.html">解决 TIME_WAIT 过多造成的问题</a></li>
</ul>
<hr>
<h5 id="nginx-配置问题">
  nginx 配置问题
  <a class="anchor" href="#nginx-%e9%85%8d%e7%bd%ae%e9%97%ae%e9%a2%98">#</a>
</h5>
<ul>
<li>nginx 在配置 &ldquo;不启用 keep-alive&rdquo; 时，会在 http 请求结束时主动断开连接
<ul>
<li>尝试开启 http 的 keep-alive</li>
</ul>
<pre tabindex="0"><code>keepalive_timeout 65;
</code></pre></li>
<li>nginx 与 fast-cgi 的默认连接是短连接
<ul>
<li>修改 nginx 配置使其与 fastcgi 的连接使用长连接</li>
</ul>
<pre tabindex="0"><code>upstream phpserver{
    server 127.0.0.1:9000 weight=1;
    # upstream 中的 keepalive 指定 nginx 每个 worker 与 fastcgi 的最大长连接数
    keepalive 100
}
</code></pre></li>
<li>若 nginx 与 fast-cgi 在同一台服务器上，则使用 unix 域 会更为高效，同时避免了 TIME_WAIT 的问题</li>
</ul>
<h6 id="proxy_pass-与-fastcgi_pass-的区别">
  proxy_pass 与 fastcgi_pass 的区别
  <a class="anchor" href="#proxy_pass-%e4%b8%8e-fastcgi_pass-%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h6>
<pre tabindex="0"><code>客户端
--http--&gt; 前端负载均衡 Nginx
--proxy_pass--&gt; 业务服务器 Nginx
--fastcgi_pass--&gt; 业务服务器 php-fpm
</code></pre><h4 id="为什么要有-time_wait-状态">
  为什么要有 TIME_WAIT 状态？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89-time_wait-%e7%8a%b6%e6%80%81">#</a>
</h4>
<ul>
<li><strong>可靠地实现 TCP 全双工连接的终止</strong>
<ul>
<li>在进行关闭连接四次挥手协议时，最后的 ACK 是由主动关闭端发出的，如果这个最终的 ACK 丢失，服务器将重发最终的 FIN</li>
<li>因此客户端必须维护状态信息允许它重发最终的 ACK。如果不维持这个状态信息，那么客户端将响应 RST 分节，服务器将此分节解释成一个错误（在 java 中会抛出 connection reset 的 SocketException)。</li>
<li>因而，要实现 TCP 全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭的客户端必须维持状态信息进入 TIME_WAIT 状态。</li>
</ul>
</li>
<li><strong>让老的重复分节在网络中消逝</strong>
<ul>
<li>在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。</li>
<li>为了避免这个情况， TCP 不允许处于 TIME_WAIT 状态的连接启动一个新的化身，因为 TIME_WAIT 状态持续 <code>2MSL</code>，就可以保证当成功建立一个 TCP 连接的时候，来自连接先前化身的重复分组已经在网络中消逝。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="参考">
  参考
  <a class="anchor" href="#%e5%8f%82%e8%80%83">#</a>
</h2>
<ul>
<li><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/">TCP/IP 详解</a></li>
<li><a href="http://www.52im.net/thread-513-1-1.html">深入理解 TCP 协议（上）：理论基础</a></li>
<li><a href="http://www.52im.net/thread-515-1-1.html">深入理解 TCP 协议（下）：RTT、滑动窗口、拥塞处理</a></li>
<li><a href="http://www.52im.net/thread-275-1-1.html">Wireshark 抓包分析 TCP 3 次握手、4 次挥手过程</a></li>
<li><a href="http://www.52im.net/thread-258-1-1.html">TCP 协议的 3 次握手与 4 次挥手过程详解</a></li>
<li><a href="http://www.52im.net/thread-1003-1-1.html">不为人知的网络编程 (一)：浅析 TCP 协议中的疑难杂症 (上篇)</a></li>
<li><a href="http://www.52im.net/thread-1004-1-1.html">不为人知的网络编程 (一)：浅析 TCP 协议中的疑难杂症 (下篇)</a></li>
<li><a href="http://www.52im.net/thread-1007-1-1.html">不为人知的网络编程 (三)：关闭 TCP 连接时为什么会 TIME_WAIT、CLOSE_WAIT</a></li>
<li><a href="http://www.52im.net/thread-561-1-1.html">高性能网络编程 (一)：单台服务器并发 TCP 连接数到底可以有多少</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/ikingye/study-network/commit/b7f460e536f3a13ab408ba9a682defadc507bb6e" title='Last modified by yewang | 2020-12-16' target="_blank" rel="noopener">
      <img src="/study-network/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>2020-12-16</span>
    </a>
  </div>



</div>

 
        <div>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <p><span id="busuanzi_container_page_pv">本文访问量 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> 次</span></p>
    <p><span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> 次</span></p>
    <p><span id="busuanzi_container_site_uv">本站总访客数 <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> 人</span></p>
</div>





      </footer>

      
  
  <div class="book-comments">
<script src="https://utteranc.es/client.js"
  repo="ikingye/study-network"
  issue-term="pathname"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>

<div id="footer">
  <p>
    <a href="https://kingye.me">叶王</a> &copy; 2013-2021
    版权所有。如果本文档对你有所帮助，可以<a
      href="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200428110046.png"
      target="_blank"
      rel="noopener noreferrer"
      >请作者喝饮料</a
    >。
  </p>
</div>

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#tcp-报文格式">TCP 报文格式</a></li>
    <li><a href="#三次握手">三次握手</a></li>
    <li><a href="#四次挥手">四次挥手</a></li>
    <li><a href="#tcp-有限状态机">TCP 有限状态机</a></li>
    <li><a href="#tcp-状态变迁图">TCP 状态变迁图</a></li>
    <li><a href="#tcp-是全双工的">TCP 是全双工的</a></li>
    <li><a href="#tcp-的-rtt-算法">TCP 的 RTT 算法</a>
      <ul>
        <li><a href="#经典算法rfc793httptoolsietforghtmlrfc793">经典算法（<a href="http://tools.ietf.org/html/rfc793">RFC793</a>）</a></li>
        <li><a href="#karn--partridge-算法">Karn / Partridge 算法</a></li>
        <li><a href="#jacobson--karels-算法">Jacobson / Karels 算法</a></li>
      </ul>
    </li>
    <li><a href="#tcp-滑动窗口">TCP 滑动窗口</a>
      <ul>
        <li><a href="#发送方的滑动窗口">发送方的滑动窗口</a></li>
        <li><a href="#接受端控制发送端的图示">接受端控制发送端的图示</a></li>
      </ul>
    </li>
    <li><a href="#tcp-的拥塞处理">TCP 的拥塞处理</a>
      <ul>
        <li><a href="#慢热启动算法--slow-start">慢热启动算法 – Slow Start</a></li>
        <li><a href="#拥塞避免算法--congestion-avoidance">拥塞避免算法 – Congestion Avoidance</a></li>
        <li><a href="#拥塞状态时的算法">拥塞状态时的算法</a></li>
        <li><a href="#快速恢复算法--fast-recovery">快速恢复算法 – Fast Recovery</a></li>
        <li><a href="#fack-算法">FACK 算法</a></li>
      </ul>
    </li>
    <li><a href="#syn-攻击">SYN 攻击</a>
      <ul>
        <li><a href="#解决">解决</a></li>
      </ul>
    </li>
    <li><a href="#问答">问答</a>
      <ul>
        <li><a href="#为什么建立连接是三次握手而关闭连接却是四次挥手呢">为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</a></li>
        <li><a href="#单台服务器并发-tcp-连接数到底可以有多少">单台服务器并发 TCP 连接数到底可以有多少？</a>
          <ul>
            <li><a href="#文件句柄限制">文件句柄限制</a>
              <ul>
                <li><a href="#进程限制">进程限制</a></li>
                <li><a href="#全局限制">全局限制</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#为什么服务总会抛出一个-connet-reset-by-peer">为什么服务总会抛出一个 <code>connet reset by peer</code>？</a></li>
        <li><a href="#出现大量-time_wait-状态怎么办">出现大量 time_wait 状态怎么办？</a>
          <ul>
            <li><a href="#time_wait-是怎么产生的">TIME_WAIT 是怎么产生的？</a>
              <ul>
                <li><a href="#连接关闭的过程">连接关闭的过程</a></li>
                <li><a href="#time_wait-只会出现在主动断开连接的一方">TIME_WAIT 只会出现在主动断开连接的一方</a></li>
              </ul>
            </li>
            <li><a href="#大量-time_wait-造成的影响">大量 TIME_WAIT 造成的影响</a></li>
            <li><a href="#排查">排查</a>
              <ul>
                <li><a href="#查看-tcp-各个状态的数量">查看 TCP 各个状态的数量</a></li>
                <li><a href="#tcp-状态含义">TCP 状态含义</a></li>
                <li><a href="#统计-time_wait-连接的本地地址">统计 TIME_WAIT 连接的本地地址</a></li>
              </ul>
            </li>
            <li><a href="#如何尽量处理-timewait-过多的问题">如何尽量处理 TIMEWAIT 过多的问题？</a>
              <ul>
                <li><a href="#修改内核文件-etcsysctlconf">修改内核文件 /etc/sysctl.conf</a></li>
                <li><a href="#nginx-配置问题">nginx 配置问题</a>
                  <ul>
                    <li><a href="#proxy_pass-与-fastcgi_pass-的区别">proxy_pass 与 fastcgi_pass 的区别</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#为什么要有-time_wait-状态">为什么要有 TIME_WAIT 状态？</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>

</html>












